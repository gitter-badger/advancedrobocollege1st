/***********************************************************************/
/*                                                                     */
/*  FILE        :intprg.c                                              */
/*  DATE        :Fri, Jul 13, 2012                                     */
/*  DESCRIPTION :Interrupt Program                                     */
/*  CPU TYPE    :H8/36064                                              */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.16).    */
/*                                                                     */
/***********************************************************************/

#include	<machine.h>
#include	"sc.h"
#include	"iodefine.h"
#include	"appli.h"


#pragma section IntPRG
//  vector 1 Reserved

//  vector 2 Reserved

//  vector 3 Reserved

//  vector 4 Reserved

//  vector 5 Reserved

//  vector 6 Reserved

//  vector 7 NMI
__interrupt(vect=7) void INT_NMI(void) {/* sleep(); */}
//  vector 8 TRAP #0
__interrupt(vect=8) void INT_TRAP0(void) {/* sleep(); */}
//  vector 9 TRAP #1
__interrupt(vect=9) void INT_TRAP1(void) {/* sleep(); */}
//  vector 10 TRAP #2
__interrupt(vect=10) void INT_TRAP2(void) {/* sleep(); */}
//  vector 11 TRAP #3
__interrupt(vect=11) void INT_TRAP3(void) {/* sleep(); */}
//  vector 12 Address break
__interrupt(vect=12) void INT_ABRK(void) {/* sleep(); */}
//  vector 13 SLEEP
__interrupt(vect=13) void INT_SLEEP(void) {/* sleep(); */}
//  vector 14 IRQ0
__interrupt(vect=14) void INT_IRQ0(void) {
}
//  vector 15 IRQ1
__interrupt(vect=15) void INT_IRQ1(void) {/* sleep(); */}
//  vector 16 IRQ2
__interrupt(vect=16) void INT_IRQ2(void) {/* sleep(); */}
//  vector 17 IRQ3
__interrupt(vect=17) void INT_IRQ3(void) {/* sleep(); */}
//  vector 18 WKP
__interrupt(vect=18) void INT_WKP(void) {/* sleep(); */}
//  vector 19 Reserved

//  vector 20 Reserved

//  vector 21 Reserved

//  vector 22 Timer V
__interrupt(vect=22) void INT_TimerV(void) {/* sleep(); */}
//  vector 23 SCI3
__interrupt(vect=23) void INT_SCI3(void){
	
	unsigned char	tmp, sdata;
	
	if(SCI3.SSR.BIT.RDRF){
		SC1_T_RS232C_RCV.data[SC1_T_RS232C_RCV.iptr] = SCI3.RDR;
		SCI3.SSR.BIT.RDRF = 0;
		SC1_T_RS232C_RCV.iptr = (SC1_T_RS232C_RCV.iptr + 1)%RB_LENGTH;
	}
	
	if(SCI3.SSR.BIT.TDRE){
		tmp = sc_rb_read(&SC1_T_RS232C_TRN, &sdata);
		if(tmp == 0){
			SCI3.SCR3.BIT.TIE = 0;
			SCI3.SCR3.BIT.TEIE = 1;
		}
		else{
			SCI3.TDR = sdata;
			SCI3.SSR.BIT.TDRE = 0;
			SCI3.SCR3.BIT.TEIE = 0;
		}
	}
	if(SCI3.SSR.BIT.TEND){
		SCI3.SSR.BYTE = 0x00;
		SCI3.SCR3.BYTE = 0x50;
	}	
	return;
}
 
//  vector 24 IIC2
__interrupt(vect=24) void INT_IIC2(void) {/* sleep(); */}
//  vector 25 ADI
__interrupt(vect=25) void INT_ADI(void){

	if((AD.ADCSR.BYTE & 0x07) == 0x07){
		//AD4-7スキャン
		++AD_FLG;
		AD.ADCSR.BIT.ADF = 0;
		
		if(AD_FLG > 10){
//			BATT_monitor();
			AD_FLG = 0;
			if(SW3 == 0)	AD.ADCSR.BYTE = 0x73;
		}
		return;
	}
	else{
		//AD0-3スキャン
		++AD_FLG;
		AD.ADCSR.BIT.ADF = 0;
		
		if(AD_FLG > 10){
			SENSOR_check(22);
			AD_FLG = 0;
			AD.ADCSR.BYTE = 0x77;
		}
		return;
	}

}
//  vector 26 Timer Z0
__interrupt(vect=26) void INT_TimerZ0(void){
	
	if(TZ0.TSR.BIT.IMFA){
		//コンペアマッチA割込
		TZ0.TSR.BIT.IMFA = 0;
		if(MDIR[0] == 2){
			MCW1 = 1;
			MCCW1 = 1;
		}
		else{
			MCW1 = 0;
			MCCW1 = 0;
		}
		return;
	}
	if(TZ0.TSR.BIT.IMFB){
		//コンペアマッチB割込
		TZ0.TSR.BIT.IMFB = 0;
		if(MDIR[1] == 2){
			MCW2 = 1;
			MCCW2 = 1;
		}
		else{
			MCW2 = 0;
			MCCW2 = 0;
		}
		return;
	}
	if(TZ0.TSR.BIT.IMFC){
		//コンペアマッチC割込
		TZ0.TSR.BIT.IMFC = 0;
		CLOCK_1MSEC_COUNTER++;
		
		if(MDIR[0] == 0){
			MCW1 = 1;
			MCCW1 = 0;
		}
		else if(MDIR[0] == 1){
			MCW1 = 0;
			MCCW1 = 1;
		}
		else if(MDIR[0] == 2){
			//BRAKE処理
			MCW1 = 1;
			MCCW1 = 1;
		}
		else{
			//モータフリー
			MCW1 = 0;
			MCCW1 = 0;
		}
		
		if(MDIR[1] == 0){
			MCW2 = 1;
			MCCW2 = 0;
		}
		else if(MDIR[1] == 1){
			MCW2 = 0;
			MCCW2 = 1;
		}
		else if(MDIR[1] == 2){
			MCW2 = 1;
			MCCW2 = 1;
		}
		else{
			MCW2 = 0;
			MCCW2 = 0;
		}
		
		if(MDIR[2] == 0){
			MCW3 = 1;
			MCCW3 = 0;
		}
		else if(MDIR[2] == 1){
			MCW3 = 0;
			MCCW3 = 1;
		}
		else if(MDIR[2] == 2){
			MCW3 = 1;
			MCCW3 = 1;
		}
		else{
			MCW3 = 0;
			MCCW3 = 0;
		}
		
		if(MDIR[3] == 0){
			MCW4 = 1;
			MCCW4 = 0;
		}
		else if(MDIR[3] == 1){
			MCW4 = 0;
			MCCW4 = 1;
		}
		else if(MDIR[3] == 2){
			MCW4 = 1;
			MCCW4 = 1;
		}
		else{
			MCW4 = 0;
			MCCW4 = 0;
		}
		return;	
	}
}

//  vector 27 Timer Z1
__interrupt(vect=27) void INT_TimerZ1(void){
	
	if(TZ1.TSR.BIT.IMFA){
		//コンペアマッチA割込
		TZ1.TSR.BIT.IMFA = 0;
		if(MDIR[2] == 2){
			MCW3 = 1;
			MCCW3 = 1;
		}
		else{
			MCW3 = 0;
			MCCW3 = 0;
		}
		return;
	}
	if(TZ1.TSR.BIT.IMFB){
		//コンペアマッチB割込
		TZ1.TSR.BIT.IMFB = 0;
		if(MDIR[3] == 2){
			MCW4 = 1;
			MCCW4 = 1;
		}
		else{
			MCW4 = 0;
			MCCW4 = 0;
		}
		return;
	}
}
//  vector 28 Reserved

//  vector 29 Timer B1
__interrupt(vect=29) void INT_TimerB1(void){
	
	CLOCK_100MSEC_COUNTER++;
		
	IRR2.BIT.IRRTB1 = 0;
	
	return;
}
	
	
	
//  vector 30 Reserved

//  vector 31 Reserved

//  vector 32 SCI3_2
__interrupt(vect=32) void INT_SCI3_2(void){
	
	unsigned char	tmp, sdata;
	
	if(SCI3_2.SSR.BIT.RDRF){
		SC2_T_RS232C_RCV.data[SC2_T_RS232C_RCV.iptr] = SCI3_2.RDR;
		SCI3_2.SSR.BIT.RDRF = 0;
		SC2_T_RS232C_RCV.iptr = (SC2_T_RS232C_RCV.iptr + 1)%RB_LENGTH;
	}
	
	if(SCI3_2.SSR.BIT.TDRE){
		tmp = sc_rb_read(&SC2_T_RS232C_TRN, &sdata);
		if(tmp == 0){
			SCI3_2.SCR3.BIT.TIE = 0;
			SCI3_2.SCR3.BIT.TEIE = 1;
		}
		else{
			SCI3_2.TDR = sdata;
			SCI3_2.SSR.BIT.TDRE = 0;
			SCI3_2.SCR3.BIT.TEIE = 0;
		}
	}
	if(SCI3_2.SSR.BIT.TEND){
		SCI3_2.SSR.BYTE = 0x00;
		SCI3_2.SCR3.BYTE = 0x50;
	}	
	return;
}
